# Solutions to Week 1, Hour 8 LeetCode-Style Problems

## 1. Map Squares
**Explanation**: Square each element using `map`.

**Solution**:
```python
# Function to square elements
def map_squares(nums):
    # Use map with lambda to square
    return list(map(lambda x: x * x, nums))

# Test the function
print(map_squares([1, 2, 3]))  # Output: [1, 4, 9]
```
**Time**: O(n), **Space**: O(n). **Pros**: Concise. **Cons**: Creates new list.

## 2. Filter Primes
**Explanation**: Filter prime numbers.

**Solution**:
```python
# Function to check if prime
def is_prime(n):
    # Handle edge cases
    if n < 2:
        return False
    # Check divisibility
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# Function to filter primes
def filter_primes(nums):
    # Filter using is_prime
    return list(filter(is_prime, nums))

# Test the function
print(filter_primes([2, 3, 4, 5]))  # Output: [2, 3, 5]
```
**Time**: O(n * sqrt(m)), **Space**: O(n). **Pros**: Functional. **Cons**: Prime check cost.

## 3. Reduce Product
**Explanation**: Compute product using `reduce`.

**Solution**:
```python
from functools import reduce

# Function to compute product
def reduce_product(nums):
    # Use reduce to multiply
    return reduce(lambda x, y: x * y, nums, 1)

# Test the function
print(reduce_product([1, 2, 3]))  # Output: 6
```
**Time**: O(n), **Space**: O(1). **Pros**: Elegant. **Cons**: Requires `functools`.

## 4. List Comprehension Evens
**Explanation**: Extract even numbers.

**Solution**:
```python
# Function to get even numbers
def get_evens(nums):
    # Use list comprehension
    return [x for x in nums if x % 2 == 0]

# Test the function
print(get_evens([1, 2, 3, 4]))  # Output: [2, 4]
```
**Time**: O(n), **Space**: O(n). **Pros**: Pythonic. **Cons**: Creates new list.

## 5. Generator Fibonacci
**Explanation**: Generate Fibonacci numbers.

**Solution**:
```python
# Function to generate Fibonacci
def fib_generator(n):
    # Initialize sequence
    a, b = 0, 1
    # Yield n numbers
    for _ in range(n):
        yield a
        a, b = b, a + b

# Test the function
print(list(fib_generator(5)))  # Output: [0, 1, 1, 2, 3]
```
**Time**: O(n), **Space**: O(1). **Pros**: Memory-efficient. **Cons**: Single-use.