# Week 1, Hour 8: Introduction to Recursion

## Agenda
This hour introduces recursion in Python, a technique where a function calls itself to solve smaller instances of a problem. Recursion is essential for coding interviews, particularly for problems involving trees, graphs, and divide-and-conquer algorithms.

## Outcome Expected
By the end of this hour, you will be able to:
- Understand and implement recursive functions.
- Identify base cases and recursive cases.
- Analyze recursion time and space complexity.
- Solve common recursive problems (e.g., factorial, Fibonacci).
- Debug recursive functions to avoid infinite recursion.
- Explain recursive logic clearly in interviews.

## Topics Covered
1. What is Recursion?
2. Base Case and Recursive Case
3. Recursion vs Iteration
4. Common Recursive Patterns
5. Time and Space Complexity
6. Interview Tips and Common Pitfalls

## Detailed Explanation of Topics

### 1. What is Recursion?
Recursion is when a function calls itself with a smaller input to solve a problem. It breaks problems into smaller subproblems until a base case is reached.

Example:
```python
# Recursive factorial function
def factorial(n):
    # Base case: factorial of 0 or 1 is 1
    if n <= 1:
        return 1
    # Recursive case: n * factorial of (n-1)
    return n * factorial(n - 1)

# Test the function
print(factorial(5))  # Output: 120 (5 * 4 * 3 * 2 * 1)
```

### 2. Base Case and Recursive Case
- **Base Case**: Condition to stop recursion.
- **Recursive Case**: Calls the function with a smaller input.

Example:
```python
# Recursive sum of first n numbers
def sum_n(n):
    # Base case: sum of 0 is 0
    if n == 0:
        return 0
    # Recursive case: n + sum of (n-1)
    return n + sum_n(n - 1)

# Test the function
print(sum_n(4))  # Output: 10 (4 + 3 + 2 + 1)
```

### 3. Recursion vs Iteration
Recursion uses function calls; iteration uses loops. Recursion is elegant for tree-like problems but can consume more stack space.

Example (Iterative vs Recursive):
```python
# Iterative factorial
def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

# Recursive factorial
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)

# Test both
print(factorial_iterative(5))  # Output: 120
print(factorial_recursive(5))  # Output: 120
```

### 4. Common Recursive Patterns
- **Divide-and-Conquer**: Split problem into halves (e.g., merge sort).
- **Tree Traversal**: Process nodes recursively.
- **Backtracking**: Explore all possibilities (e.g., permutations).

Example (Fibonacci):
```python
# Recursive Fibonacci
def fibonacci(n):
    # Base cases: fib(0)=0, fib(1)=1
    if n <= 1:
        return n
    # Recursive case: fib(n) = fib(n-1) + fib(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2)

# Test the function
print(fibonacci(6))  # Output: 8 (0, 1, 1, 2, 3, 5, 8)
```

### 5. Time and Space Complexity
- **Time Complexity**: Often exponential (e.g., O(2^n) for naive Fibonacci) without optimization.
- **Space Complexity**: O(n) for call stack in most cases.
- **Optimization**: Use memoization to cache results.

Example (Memoized Fibonacci):
```python
# Memoized Fibonacci
def fibonacci_memo(n, memo={}):
    # Check if result is cached
    if n in memo:
        return memo[n]
    # Base cases
    if n <= 1:
        return n
    # Recursive case with memoization
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# Test the function
print(fibonacci_memo(6))  # Output: 8
```

### 6. Interview Tips and Common Pitfalls
- **Tips**:
  - Always define a clear base case to avoid infinite recursion.
  - Explain recursive logic step-by-step in interviews.
  - Use memoization for overlapping subproblems.
- **Pitfalls**:
  - Missing base case (infinite recursion).
  - Stack overflow for large inputs.
  - Not considering iterative alternatives for efficiency.

Example (Safe Recursion):
```python
# Recursive sum with error handling
def safe_sum_n(n):
    # Check for negative input
    if n < 0:
        raise ValueError("Input must be non-negative")
    # Base case
    if n == 0:
        return 0
    # Recursive case
    return n + safe_sum_n(n - 1)

# Test with try-except
try:
    print(safe_sum_n(4))  # Output: 10
    print(safe_sum_n(-1))  # Raises ValueError
except ValueError as e:
    print(e)  # Output: Input must be non-negative
```

## Points to Remember
- Recursion solves problems by breaking them into smaller subproblems.
- Always define a base case to stop recursion.
- Recursive calls add to the call stack, impacting space complexity.
- Use memoization to optimize overlapping subproblems.
- Explain recursion clearly in interviews (e.g., “This base case stops at n=0”).
- Common error: Missing base case causes infinite recursion.
- Test edge cases: n=0, negative inputs, large inputs.
- Consider iterative solutions for large inputs to avoid stack overflow.
- Visualize recursive calls as a tree for clarity.
- Practice verbalizing recursive steps for interviews.