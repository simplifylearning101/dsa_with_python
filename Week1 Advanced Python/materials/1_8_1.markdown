# Week 1, Hour 8: Advanced Functional Programming in Python

## Agenda
This hour explores advanced functional programming in Python, focusing on tools like lambda functions, `map`, `filter`, `reduce`, list comprehensions, generators, and decorators. These features enable concise, expressive code, which is highly valued in coding interviews and Pythonic programming.

## Outcome Expected
By the end of this hour, you will be able to:
- Use lambda functions for inline operations.
- Apply `map`, `filter`, and `reduce` for functional transformations.
- Write efficient list comprehensions and generator expressions.
- Implement generators for memory-efficient iteration.
- Create and use decorators to modify function behavior.
- Explain functional programming concepts in interviews.

## Topics Covered
1. Lambda Functions
2. Map, Filter, and Reduce
3. List Comprehensions and Generator Expressions
4. Generators and Iterators
5. Decorators
6. Interview Tips and Common Pitfalls

## Detailed Explanation of Topics

### 1. Lambda Functions
Lambda functions are anonymous functions defined using the `lambda` keyword. They’re useful for short, throwaway functions in functional programming.

Example:
```python
# Lambda function to square a number
square = lambda x: x * x
# Use lambda
print(square(5))  # Output: 25

# Lambda with multiple arguments
add = lambda x, y: x + y
print(add(3, 4))  # Output: 7
```

### 2. Map, Filter, and Reduce
These functions apply operations to iterables:
- `map`: Applies a function to each element.
- `filter`: Selects elements based on a condition.
- `reduce`: Combines elements into a single result.

Example:
```python
from functools import reduce

# Map: Square each number
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x * x, numbers))
print(squared)  # Output: [1, 4, 9, 16]

# Filter: Keep even numbers
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # Output: [2, 4]

# Reduce: Sum all numbers
total = reduce(lambda x, y: x + y, numbers)
print(total)  # Output: 10
```

### 3. List Comprehensions and Generator Expressions
List comprehensions create lists concisely; generator expressions create iterators for memory efficiency.

Example:
```python
# List comprehension
squares = [x * x for x in range(5)]
print(squares)  # Output: [0, 1, 4, 9, 16]

# Generator expression
squares_gen = (x * x for x in range(5))
print(list(squares_gen))  # Output: [0, 1, 4, 9, 16]
```

### 4. Generators and Iterators
Generators yield values one at a time, saving memory for large datasets. Defined using `yield` or generator expressions.

Example:
```python
# Generator function
def fibonacci(n):
    # Initialize first two numbers
    a, b = 0, 1
    # Yield n Fibonacci numbers
    for _ in range(n):
        yield a
        a, b = b, a + b

# Use generator
print(list(fibonacci(5)))  # Output: [0, 1, 1, 2, 3]
```

### 5. Decorators
Decorators wrap functions to modify their behavior, often used for logging, timing, or access control.

Example:
```python
# Decorator to log function calls
def logger(func):
    # Wrapper function
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"Finished {func.__name__}, result: {result}")
        return result
    return wrapper

# Apply decorator
@logger
def add(x, y):
    return x + y

# Test the function
print(add(2, 3))  # Output: Calling add with (2, 3), {}; Finished add, result: 5; 5
```

### 6. Interview Tips and Common Pitfalls
- **Tips**:
  - Use lambda functions for concise solutions in interviews.
  - Prefer list comprehensions over loops for Pythonic code.
  - Use generators for memory-efficient solutions with large data.
  - Explain decorators by describing their wrapping behavior.
- **Pitfalls**:
  - Overusing lambda functions for complex logic.
  - Forgetting to import `reduce` from `functools`.
  - Exhausting generators (they’re single-use).
  - Misplacing `@` in decorator syntax.

Example (Safe Generator):
```python
# Generator with error handling
def safe_fibonacci(n):
    # Check for valid input
    if n < 0:
        raise ValueError("Input must be non-negative")
    # Initialize Fibonacci sequence
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Test with try-except
try:
    print(list(safe_fibonacci(5)))  # Output: [0, 1, 1, 2, 3]
    print(list(safe_fibonacci(-1)))  # Raises ValueError
except ValueError as e:
    print(e)  # Output: Input must be non-negative
```

## Points to Remember
- Lambda functions are concise but should be simple.
- `map`, `filter`, `reduce` transform iterables functionally.
- List comprehensions are Pythonic; generator expressions save memory.
- Generators yield values lazily, ideal for large datasets.
- Decorators modify function behavior using wrappers.
- Common error: Forgetting to handle exhausted generators.
- Test edge cases: empty iterables, invalid inputs.
- Explain functional programming benefits (e.g., conciseness, immutability).
- Use `@` syntax for decorators, ensure proper wrapping.
- Practice verbalizing functional logic (e.g., “This maps a lambda to square each element”).