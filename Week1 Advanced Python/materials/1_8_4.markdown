# Week 1, Hour 8 Quiz: 30 Questions

Covers Hour 8 and some Week 0/Hour 1-7 concepts.

1. What is recursion?  
2. Purpose of base case?  
3. Compute factorial of 3. (Code)  
4. Output of `sum_n(3)`?  
5. What is recursive case?  
6. True or False: Recursion always uses less memory than iteration.  
7. Reverse "abc". (Code)  
8. What is memoization?  
9. Compute 2^4. (Code)  
10. Why explain recursion in interviews?  
11. Output of `fibonacci(5)`?  
12. Common recursion error?  
13. Sum [1, 2]. (Code)  
14. What is call stack in recursion?  
15. True or False: Recursion can cause stack overflow.  
16. Count digits in 1234. (Code)  
17. Why use memoization?  
18. Find max in [3, 1, 4]. (Code)  
19. Output of `is_palindrome("deed")`?  
20. Why test base cases?  
21. Generate first 4 Fibonacci numbers. (Code)  
22. What is divide-and-conquer?  
23. Compute sum_n(5). (Code)  
24. Why avoid deep recursion?  
25. Output of `factorial(4)`?  
26. Check palindrome "aba". (Code)  
27. Why handle negative inputs?  
28. Compute 3^2. (Code)  
29. Output of `sum_list([4, 5])`?  
30. When to use recursion vs iteration?

## Solutions for the Quiz
1. Function calling itself with smaller input.  
2. Stops recursion.  
3. `def factorial(n): if n <= 1: return 1; return n * factorial(n-1)`  
4. 6  
5. Function call with smaller input.  
6. False  
7. `def reverse(s): if len(s) <= 1: return s; return s[-1] + reverse(s[:-1])`  
8. Caching results to avoid recomputation.  
9. `def power(base, exp): if exp == 0: return 1; return base * power(base, exp-1)`  
10. Shows problem-solving clarity.  
11. 5  
12. Missing base case.  
13. `def sum_list(lst): if not lst: return 0; return lst[0] + sum_list(lst[1:])`  
14. Tracks function calls.  
15. True  
16. `def count_digits(n): n = abs(n); if n < 10: return 1; return 1 + count_digits(n//10)`  
17. Improves efficiency for overlapping subproblems.  
18. `def find_max(lst): if len(lst) == 1: return lst[0]; return max(lst[0], find_max(lst[1:]))`  
19. True  
20. Ensures recursion terminates.  
21. `def fib_list(n): return [fib(i) for i in range(n)] where def fib(i): if i <= 1: return i; return fib(i-1) + fib(i-2)`  
22. Split problem into smaller parts.  
23. `def sum_n(n): if n == 0: return 0; return n + sum_n(n-1)`  
24. Risks stack overflow.  
25. 24  
26. `def is_palindrome(s): if len(s) <= 1: return True; if s[0] != s[-1]: return False; return is_palindrome(s[1:-1])`  
27. Prevents invalid recursion.  
28. `def power(base, exp): if exp == 0: return 1; return base * power(base, exp-1)`  
29. 9  
30. Recursion for tree-like problems; iteration for linear ones.