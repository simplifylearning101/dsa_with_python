# Week 1, Hour 9 Quiz: 30 Questions

Covers Hour 9 and some Week 0/Hour 1-8 concepts.

1. What is the `collections` module?  
2. Purpose of `Counter`?  
3. Count ['x', 'y', 'x'] using `Counter`. (Code)  
4. Output of `Counter([1, 2, 1]).most_common(1)`?  
5. What is `deque`?  
6. True or False: `deque` has O(1) appends.  
7. Implement stack pop using `deque`. (Code)  
8. What is `defaultdict`?  
9. Create `namedtuple` for Car. (Code)  
10. Why use `collections` in interviews?  
11. Output of `deque([1, 2]).popleft()`?  
12. Common `deque` error?  
13. Group ['a', 'bb'] by length. (Code)  
14. What is `OrderedDict`?  
15. True or False: Lists are efficient for queues.  
16. Append 3 to linked list with [1, 2]. (Code)  
17. Why use `namedtuple`?  
18. Find most common in [1, 1, 2]. (Code)  
19. Output of `defaultdict(int)['a']`?  
20. Why test empty inputs?  
21. Rotate [1, 2, 3] by -1. (Code)  
22. What is a linked list?  
23. Create queue with `deque`. (Code)  
24. Why prefer `deque` over list?  
25. Output of `OrderedDict([('a', 1), ('b', 2)])`?  
26. Delete 2 from linked list [1, 2, 3]. (Code)  
27. Why use custom data structures?  
28. Create `Counter` from [1, 2]. (Code)  
29. Output of `deque([1, 2]).rotate(1)`?  
30. When to use `Counter` vs dictionary?

## Solutions for the Quiz
1. Module with specialized container datatypes.  
2. Counts hashable objects.  
3. `from collections import Counter; Counter(['x', 'y', 'x'])`  
4. [(1, 2)]  
5. Double-ended queue with O(1) operations.  
6. True  
7. `from collections import deque; s = deque([1, 2]); s.pop()`  
8. Dictionary with default value for missing keys.  
9. `from collections import namedtuple; Car = namedtuple('Car', ['make', 'model'])`  
10. Shows efficient, Pythonic solutions.  
11. 1  
12. Accessing empty deque.  
13. `from collections import defaultdict; dd = defaultdict(list); for s in ['a', 'bb']: dd[len(s)].append(s); dict(dd)`  
14. Dictionary that maintains insertion order.  
15. False  
16. `class Node: def __init__(self, data): self.data = data; self.next = None; class LinkedList: def __init__(self): self.head = None; def append(self, data): new_node = Node(data); if not self.head: self.head = new_node; return; curr = self.head; while curr.next: curr = curr.next; curr.next = new_node; def display(self): result = []; curr = self.head; while curr: result.append(curr.data); curr = curr.next; return result; ll = LinkedList(); ll.append(1); ll.append(2); ll.append(3)`  
17. Lightweight, readable objects.  
18. `from collections import Counter; Counter([1, 1, 2]).most_common(1)[0]`  
19. 0  
20. Ensures robust code.  
21. `from collections import deque; dq = deque([1, 2, 3]); dq.rotate(-1); list(dq)`  
22. Data structure with nodes linked by pointers.  
23. `from collections import deque; q = deque(); q.append(1); q.append(2)`  
24. O(1) operations vs O(n) for list.  
25. OrderedDict([('a', 1), ('b', 2)])  
26. `class Node: def __init__(self, data): self.data = data; self.next = None; class LinkedList: def __init__(self): self.head = None; def append(self, data): new_node = Node(data); if not self.head: self.head = new_node; return; curr = self.head; while curr.next: curr = curr.next; curr.next = new_node; def delete(self, data): if not self.head: return; if self.head.data == data: self.head = self.head.next; return; curr = self.head; while curr.next and curr.next.data != data: curr = curr.next; if curr.next: curr.next = curr.next.next; def display(self): result = []; curr = self.head; while curr: result.append(curr.data); curr = curr.next; return result; ll = LinkedList(); ll.append(1); ll.append(2); ll.append(3); ll.delete(2)`  
27. For specific performance needs.  
28. `from collections import Counter; Counter([1, 2])`  
29. [2, 1] (after list conversion)  
30. `Counter` for frequency; dictionary for general mappings.