# Solutions to Week 1, Hour 9 Homework Problems

Solutions with extensively commented code for clarity.

**Problem 1**:
```python
# Memoized Fibonacci
def fib_memo(n, memo={}):
    # Check cache
    if n in memo:
        return memo[n]
    # Base cases
    if n <= 1:
        return n
    # Recursive case with memoization
    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    return memo[n]

# Test the function
print(fib_memo(6))  # Output: 8
```

**Problem 2**:
```python
# Tabulated Fibonacci
def fib_tab(n):
    # Initialize table
    dp = [0] * (n + 1)
    # Base case
    if n >= 1:
        dp[1] = 1
    # Fill table
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

# Test the function
print(fib_tab(6))  # Output: 8
```

**Problem 3**:
```python
# Ways to climb n stairs
def climb_stairs(n):
    # Handle base cases
    if n <= 1:
        return 1
    # Initialize variables
    prev, curr = 1, 1
    # Compute ways
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    return curr

# Test the function
print(climb_stairs(3))  # Output: 3
```

**Problem 4**:
```python
# Minimum cost to reach nth step
def min_cost_climbing_stairs(cost):
    # Initialize dp array
    dp = [0] * (len(cost) + 1)
    # Fill dp table
    for i in range(2, len(cost) + 1):
        # Min cost: take step from i-1 or i-2
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
    return dp[len(cost)]

# Test the function
print(min_cost_climbing_stairs([10, 15, 20]))  # Output: 15
```

**Problem 5**:
```python
# Longest increasing subsequence length
def lengthOfLIS(nums):
    # Initialize dp array with 1s
    dp = [1] * len(nums)
    # Compute LIS for each index
    for i in range(1, len(nums)):
        for j in range(i):
            # If nums[i] can extend subsequence
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp) if dp else 0

# Test the function
print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # Output: 4
```

**Problem 6**:
```python
# Number of ways to make change
def coin_change(amount, coins):
    # Initialize dp array
    dp = [0] * (amount + 1)
    # Base case: one way to make 0
    dp[0] = 1
    # Fill dp for each coin
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]

# Test the function
print(coin_change(5, [1, 2, 5]))  # Output: 4
```

**Problem 7**:
```python
# Max sum of non-adjacent elements
def rob(nums):
    # Handle base cases
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    # Initialize dp
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    # Fill dp
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]

# Test the function
print(rob([5, 5, 10, 100, 10, 5]))  # Output: 110
```

**Problem 8**:
```python
# Min path sum in grid
def minPathSum(grid):
    # Get dimensions
    m, n = len(grid), len(grid[0])
    # Initialize dp table
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    # Fill first row
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    # Fill first column
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    # Fill rest of dp
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    return dp[m - 1][n - 1]

# Test the function
print(minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]))  # Output: 7
```

**Problem 9**:
```python
# Factorial using tabulation
def factorial_tab(n):
    # Initialize dp array
    dp = [1] * (n + 1)
    # Fill dp
    for i in range(1, n + 1):
        dp[i] = i * dp[i - 1]
    return dp[n]

# Test the function
print(factorial_tab(5))  # Output: 120
```

**Problem 10**:
```python
# Longest common subsequence length
def longestCommonSubsequence(text1, text2):
    # Initialize dp table
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    # Fill dp
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

# Test the function
print(longestCommonSubsequence("ABCD", "ACFD"))  # Output: 3
```