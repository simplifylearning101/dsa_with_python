# Week 1, Hour 8 Deep Dive: Mastering Functional Programming for Interviews

This section explores advanced functional programming techniques with heavily commented programs and interview scenarios.

## Complex Topics and Programs
- **Chaining Functional Operations**: Combine `map`, `filter`, and list comprehensions.

Example: Chained Operations
```python
# Chain map and filter to process numbers
def process_numbers(nums):
    # Filter evens, then square
    result = list(map(lambda x: x * x, filter(lambda x: x % 2 == 0, nums)))
    return result

# Test the function
print(process_numbers([1, 2, 3, 4]))  # Output: [4, 16]
```

- **Advanced Decorator with Arguments**: Create a decorator to retry function calls.

Example: Retry Decorator
```python
import time

# Decorator to retry function
def retry(max_attempts):
    # Decorator function
    def decorator(func):
        # Wrapper function
        def wrapper(*args, **kwargs):
            # Try up to max_attempts
            for attempt in range(max_attempts):
                try:
                    # Call function
                    return func(*args, **kwargs)
                except Exception as e:
                    # Log failure
                    print(f"Attempt {attempt + 1} failed: {e}")
                    if attempt == max_attempts - 1:
                        raise
                    time.sleep(1)  # Wait before retry
        return wrapper
    return decorator

# Test function
@retry(max_attempts=3)
def risky_operation(x):
    if x < 0:
        raise ValueError("Negative input")
    return x * 2

# Test the function
print(risky_operation(5))  # Output: 10
```

## Interview Questions and Answers
1. **Why use functional programming in Python?**  
   **Answer**: Enables concise, readable code with immutable transformations. **Intent**: Pythonic style.

2. **Write a lambda to compute cube.**  
   **Answer**:
   ```python
   # Lambda to compute cube
   cube = lambda x: x ** 3
   # Test the function
   print(cube(2))  # Output: 8
   ```
   **Intent**: Concise function.

3. **How to handle exhausted generators?**  
   **Answer**: Create new generator or store results in list. **Intent**: Robustness.

4. **Write a decorator to log inputs.**  
   **Answer**:
   ```python
   # Decorator to log inputs
   def log_inputs(func):
       # Wrapper function
       def wrapper(*args, **kwargs):
           # Log inputs
           print(f"Inputs: {args}, {kwargs}")
           # Call function
           return func(*args, **kwargs)
       return wrapper
   # Test function
   @log_inputs
   def add(x, y):
       return x + y
   # Test the function
   print(add(2, 3))  # Output: Inputs: (2, 3), {}; 5
   ```
   **Intent**: Function modification.

5. **Why use list comprehensions over loops?**  
   **Answer**: More concise, readable, and Pythonic. **Intent**: Code quality.