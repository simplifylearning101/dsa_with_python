# Solutions to Week 1, Hour 9 LeetCode-Style Problems

## 1. Character Frequency
**Explanation**: Count character frequency using `Counter`.

**Solution**:
```python
from collections import Counter

# Count character frequency
def char_frequency(s):
    # Create Counter
    return dict(Counter(s))

# Test the function
print(char_frequency("hello"))  # Output: {'h': 1, 'e': 1, 'l': 2, 'o': 1}
```
**Time**: O(n), **Space**: O(k). **Pros**: Simple. **Cons**: Limited to hashable items.

## 2. Sliding Window Maximum
**Explanation**: Find max in each k-sized window using `deque`.

**Solution**:
```python
from collections import deque

# Find max in sliding window
def max_sliding_window(nums, k):
    # Initialize deque
    dq = deque()
    result = []
    # Process each element
    for i in range(len(nums)):
        # Remove indices outside window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Remove smaller elements
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        # Add current index
        dq.append(i)
        # Add max if window is full
        if i >= k - 1:
            result.append(nums[dq[0]])
    return result

# Test the function
print(max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3))  # Output: [3, 3, 5, 5, 6, 7]
```
**Time**: O(n), **Space**: O(k). **Pros**: Efficient. **Cons**: Complex logic.

## 3. Group Anagrams
**Explanation**: Group anagrams using `defaultdict`.

**Solution**:
```python
from collections import defaultdict

# Group anagrams
def group_anagrams(strs):
    # Initialize defaultdict
    groups = defaultdict(list)
    # Group by sorted string
    for s in strs:
        key = ''.join(sorted(s))
        groups[key].append(s)
    return list(groups.values())

# Test the function
print(group_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))  
# Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
```
**Time**: O(n * k * log k), **Space**: O(n). **Pros**: Clean. **Cons**: Sorting cost.

## 4. LRU Cache
**Explanation**: Implement LRU cache with `OrderedDict`.

**Solution**:
```python
from collections import OrderedDict

# LRU Cache implementation
class LRUCache:
    def __init__(self, capacity):
        # Initialize OrderedDict and capacity
        self.cache = OrderedDict()
        self.capacity = capacity
    
    # Get value by key
    def get(self, key):
        # If key exists, move to end (recent)
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return -1
    
    # Put key-value pair
    def put(self, key, value):
        # If key exists, update and move to end
        if key in self.cache:
            self.cache.pop(key)
        # If at capacity, remove least recent
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        # Add new key-value
        self.cache[key] = value

# Test the cache
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Output: 1
cache.put(3, 3)
print(cache.get(2))  # Output: -1
```
**Time**: O(1) for get/put, **Space**: O(capacity). **Pros**: Efficient. **Cons**: OrderedDict-specific.

## 5. Min Heap Push/Pop
**Explanation**: Implement min heap operations.

**Solution**:
```python
# MinHeap class
class MinHeap:
    def __init__(self):
        # Initialize heap
        self.heap = []
    
    # Push item
    def push(self, val):
        self.heap.append(val)
        self._bubble_up(len(self.heap) - 1)
    
    # Bubble up
    def _bubble_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._bubble_up(parent)
    
    # Pop minimum
    def pop(self):
        if not self.heap:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._bubble_down(0)
        return min_val
    
    # Bubble down
    def _bubble_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._bubble_down(smallest)

# Test the heap
heap = MinHeap()
heap.push(3)
heap.push(1)
heap.push(2)
print(heap.pop())  # Output: 1
```
**Time**: O(log n) for push/pop, **Space**: O(n). **Pros**: Flexible. **Cons**: Manual implementation.