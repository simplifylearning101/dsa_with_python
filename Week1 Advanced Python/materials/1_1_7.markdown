# Solutions to Week 1, Hour 1 LeetCode Problems

## 1. Remove Duplicates from Sorted Array
**Explanation**: Remove duplicates in-place, return new length.

**Brute-Force**:
```python
def removeDuplicates(nums):
    nums[:] = sorted(set(nums))  # New list
    return len(nums)
```
**Time**: O(n log n), **Space**: O(n). **Pros**: Simple. **Cons**: Not in-place.

**Optimized** (Two-pointer):
```python
def removeDuplicates(nums):
    if not nums: return 0
    write = 1
    for read in range(1, len(nums)):
        if nums[read] != nums[write-1]:
            nums[write] = nums[read]
            write += 1
    return write
```
**Time**: O(n), **Space**: O(1). **Pros**: In-place. **Cons**: More logic.

## 2. Move Zeroes
**Explanation**: Move zeros to end, keep non-zero order.

**Brute-Force**:
```python
def moveZeroes(nums):
    non_zeros = [x for x in nums if x != 0]
    zeros = [0] * (len(nums) - len(non_zeros))
    nums[:] = non_zeros + zeros
```
**Time**: O(n), **Space**: O(n). **Pros**: Clear. **Cons**: Extra space.

**Optimized** (Two-pointer):
```python
def moveZeroes(nums):
    non_zero_pos = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[non_zero_pos], nums[i] = nums[i], nums[non_zero_pos]
            non_zero_pos += 1
```
**Time**: O(n), **Space**: O(1). **Pros**: In-place. **Cons**: Swapping logic.

## 3. Rotate Array
**Explanation**: Rotate array right by k steps.

**Brute-Force**:
```python
def rotate(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
```
**Time**: O(n), **Space**: O(n). **Pros**: Simple. **Cons**: Extra space.

**Optimized** (Reverse):
```python
def rotate(nums, k):
    k = k % len(nums)
    def reverse(start, end):
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1
    reverse(0, len(nums)-1)
    reverse(0, k-1)
    reverse(k, len(nums)-1)
```
**Time**: O(n), **Space**: O(1). **Pros**: In-place. **Cons**: Complex.

## 4. Merge Sorted Array
**Explanation**: Merge two sorted arrays in-place.

**Brute-Force**:
```python
def merge(nums1, m, nums2, n):
    nums1[:m+n] = sorted(nums1[:m] + nums2[:n])
```
**Time**: O((m+n) log (m+n)), **Space**: O(m+n). **Pros**: Easy. **Cons**: Not in-place.

**Optimized** (Backward merge):
```python
def merge(nums1, m, nums2, n):
    p1, p2, p = m-1, n-1, m+n-1
    while p2 >= 0 and p1 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```
**Time**: O(m+n), **Space**: O(1). **Pros**: In-place. **Cons**: Backward logic.

## 5. Plus One
**Explanation**: Increment digit array.

**Brute-Force**:
```python
def plusOne(digits):
    num = int("".join(map(str, digits))) + 1
    return [int(d) for d in str(num)]
```
**Time**: O(n), **Space**: O(n). **Pros**: Simple. **Cons**: String conversion.

**Optimized**:
```python
def plusOne(digits):
    for i in range(len(digits)-1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
    return [1] + digits
```
**Time**: O(n), **Space**: O(1). **Pros**: In-place. **Cons**: Edge case handling.