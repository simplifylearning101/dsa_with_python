# Week 1, Hour 5 Quiz: 30 Questions

Covers Hour 5 and some Week 0/Hour 1-4 concepts.

1. What is the two-pointer technique?  
2. Purpose of sliding window?  
3. Reverse array [1, 2, 3]. (Code)  
4. Output of max sum of 2 elements in [1, 2, 3]?  
5. What is a fixed window?  
6. True or False: Two-pointer always requires sorting.  
7. Find pair summing to 6 in [1, 2, 3, 4]. (Code)  
8. What is variable window?  
9. Remove duplicates from [1, 1, 2]. (Code)  
10. Why use two-pointer in interviews?  
11. Output of longest substring in "abcab"?  
12. Common error with two-pointer?  
13. Move zeros in [0, 1, 0]. (Code)  
14. What is time complexity of sliding window?  
15. True or False: Sliding window uses O(n) space.  
16. Find min window sum >= 5 in [1, 2, 3]. (Code)  
17. Why visualize pointers in interviews?  
18. Partition [2, 1, 3] around 2. (Code)  
19. Output of pair count with diff 1 in [1, 2, 3]?  
20. Why test empty arrays?  
21. Check one edit away for "helo", "hello". (Code)  
22. What is window resizing?  
23. Max sum of 3 elements in [1, 2, 3, 4]. (Code)  
24. Why avoid nested loops?  
25. Output of remove duplicates in [1, 1, 1]?  
26. Find pair summing to 8 in [1, 3, 5, 4]. (Code)  
27. Why handle edge cases?  
28. Longest substring in "aaaa". (Code)  
29. Output of partition [3, 1, 4] around 3?  
30. When to use sliding window vs two-pointer?

## Solutions for the Quiz
1. Uses two indices to traverse array/string.  
2. Processes subarray/substring efficiently.  
3. `left, right = 0, len(nums)-1; while left < right: nums[left], nums[right] = nums[right], nums[left]; left += 1; right -= 1`  
4. 5 (2 + 3)  
5. Constant-size window.  
6. False  
7. `left, right = 0, len(nums)-1; while left < right: if nums[left] + nums[right] == 6: return [left, right]; elif nums[left] + nums[right] < 6: left += 1; else: right -= 1`  
8. Window size changes based on condition.  
9. `write = 1; for read in range(1, len(nums)): if nums[read] != nums[write-1]: nums[write] = nums[read]; write += 1; return write`  
10. Reduces time complexity.  
11. 3 ("abc")  
12. Off-by-one errors.  
13. `non_zero = 0; for i in range(len(nums)): if nums[i] != 0: nums[non_zero], nums[i] = nums[i], nums[non_zero]; non_zero += 1`  
14. Usually O(n).  
15. False (often O(1)).  
16. `curr_sum = start = 0; min_len = float('inf'); for end in range(len(nums)): curr_sum += nums[end]; while curr_sum >= 5: min_len = min(min_len, end - start + 1); curr_sum -= nums[start]; start += 1; return min_len`  
17. Clarifies logic.  
18. `left = 0; for i in range(len(nums)): if nums[i] < 2: nums[left], nums[i] = nums[i], nums[left]; left += 1`  
19. 2 ([1,2], [2,3])  
20. Common edge case.  
21. `i = j = edits = 0; while i < len(s1) and j < len(s2): if s1[i] != s2[j]: edits += 1; if len(s1) < len(s2): j += 1; else: i += 1; j += 1; if edits > 1: return False; else: i += 1; j += 1; return edits + (len(s2) - j) <= 1`  
22. Adjusting window size dynamically.  
23. `window_sum = sum(nums[:3]); max_sum = window_sum; for i in range(3, len(nums)): window_sum += nums[i] - nums[i-3]; max_sum = max(max_sum, window_sum)`  
24. Higher time complexity.  
25. 1  
26. `left, right = 0, len(nums)-1; while left < right: if nums[left] + nums[right] == 8: return [left, right]; elif nums[left] + nums[right] < 8: left += 1; else: right -= 1`  
27. Ensures robustness.  
28. `seen = {}; start = max_len = 0; for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1; max_len = max(max_len, end - start + 1); seen[s[end]] = end; return max_len`  
29. [1, 4, 3]  
30. Sliding window for subarray/substring; two-pointer for pairs/partition.