# Week 1, Hour 9: Advanced Data Structures and Collections

## Agenda
This hour explores advanced data structures in Python, focusing on the `collections` module (`Counter`, `deque`, `defaultdict`, `OrderedDict`, `namedtuple`) and implementing custom data structures. These tools are essential for writing efficient, Pythonic code in coding interviews and real-world applications.

## Outcome Expected
By the end of this hour, you will be able to:
- Use `collections` module classes effectively.
- Implement custom data structures (e.g., linked lists, stacks).
- Optimize solutions using specialized data structures.
- Analyze time and space complexity of operations.
- Explain use cases for `collections` and custom structures in interviews.
- Handle edge cases and errors in data structure operations.

## Topics Covered
1. Overview of `collections` Module
2. `Counter` for Counting Elements
3. `deque` for Efficient Queues and Stacks
4. `defaultdict` and `OrderedDict`
5. `namedtuple` for Lightweight Objects
6. Custom Data Structures
7. Interview Tips and Common Pitfalls

## Detailed Explanation of Topics

### 1. Overview of `collections` Module
The `collections` module provides specialized container datatypes that enhance Python’s built-in lists, dictionaries, and tuples. These are optimized for specific use cases, such as counting, queues, or ordered mappings.

### 2. `Counter` for Counting Elements
`Counter` counts hashable objects, ideal for frequency analysis.

Example:
```python
from collections import Counter

# Create a Counter from a list
freq = Counter(['apple', 'banana', 'apple', 'orange'])
# Access counts
print(freq)  # Output: Counter({'apple': 2, 'banana': 1, 'orange': 1})
# Most common elements
print(freq.most_common(2))  # Output: [('apple', 2), ('banana', 1)]
```

### 3. `deque` for Efficient Queues and Stacks
`deque` (double-ended queue) supports O(1) appends and pops from both ends, unlike lists (O(n) for left-end operations).

Example:
```python
from collections import deque

# Create a deque
dq = deque([1, 2, 3])
# Append and pop operations
dq.append(4)  # Add to right
dq.appendleft(0)  # Add to left
print(dq)  # Output: deque([0, 1, 2, 3, 4])
dq.pop()  # Remove from right
dq.popleft()  # Remove from left
print(dq)  # Output: deque([1, 2, 3])
```

### 4. `defaultdict` and `OrderedDict`
- `defaultdict`: Provides a default value for missing keys.
- `OrderedDict`: Maintains insertion order of keys (pre-Python 3.7).

Example:
```python
from collections import defaultdict, OrderedDict

# defaultdict with list as default
dd = defaultdict(list)
dd['a'].append(1)
print(dd)  # Output: defaultdict(<class 'list'>, {'a': [1]})

# OrderedDict
od = OrderedDict()
od['x'] = 1
od['y'] = 2
print(od)  # Output: OrderedDict([('x', 1), ('y', 2)])
```

### 5. `namedtuple` for Lightweight Objects
`namedtuple` creates tuple-like objects with named fields, useful for readable data structures.

Example:
```python
from collections import namedtuple

# Define namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
print(p)  # Output: Point(x=1, y=2)
print(p.x, p.y)  # Output: 1 2
```

### 6. Custom Data Structures
Custom data structures (e.g., linked lists, stacks) can be implemented using classes for specific needs.

Example (Singly Linked List):
```python
# Node class for linked list
class Node:
    def __init__(self, data):
        # Store data and next pointer
        self.data = data
        self.next = None

# LinkedList class
class LinkedList:
    def __init__(self):
        # Initialize empty list
        self.head = None
    
    # Append data
    def append(self, data):
        # Create new node
        new_node = Node(data)
        # If list is empty
        if not self.head:
            self.head = new_node
            return
        # Traverse to end
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = new_node
    
    # Print list
    def display(self):
        result = []
        curr = self.head
        while curr:
            result.append(curr.data)
            curr = curr.next
        return result

# Test the linked list
ll = LinkedList()
ll.append(1)
ll.append(2)
print(ll.display())  # Output: [1, 2]
```

### 7. Interview Tips and Common Pitfalls
- **Tips**:
  - Use `Counter` for frequency-based problems.
  - Prefer `deque` over lists for queue/stack operations.
  - Explain why a specific collection is chosen (e.g., “`deque` for O(1) pops”).
  - Implement custom structures only when necessary.
- **Pitfalls**:
  - Using lists for queue operations (slow left-end pops).
  - Forgetting to handle empty data structures.
  - Overcomplicating solutions with custom structures.

Example (Safe Counter):
```python
from collections import Counter

# Safe Counter with error handling
def safe_counter(items):
    # Check for empty input
    if not items:
        return Counter()
    # Create Counter
    return Counter(items)

# Test with try-except
try:
    print(safe_counter(['a', 'b', 'a']))  # Output: Counter({'a': 2, 'b': 1})
    print(safe_counter([]))  # Output: Counter()
except Exception as e:
    print(e)
```

## Points to Remember
- `collections` module optimizes common data structure tasks.
- `Counter` is ideal for frequency counting.
- `deque` provides O(1) operations for queues/stacks.
- `defaultdict` avoids key errors; `OrderedDict` ensures order (pre-3.7).
- `namedtuple` creates lightweight, readable objects.
- Custom data structures offer flexibility but require careful implementation.
- Common error: Using lists for inefficient operations.
- Test edge cases: empty inputs, invalid data.
- Explain complexity benefits (e.g., `deque` vs list).
- Practice verbalizing use cases (e.g., “`Counter` for quick frequency analysis”).