# Solutions to Week 1, Hour 5 Homework Problems

Solutions with extensively commented code for clarity.

**Problem 1**:
```python
# Function to reverse array using two pointers
def reverse_array(nums):
    # Initialize left pointer at start of array
    left = 0
    # Initialize right pointer at end of array
    right = len(nums) - 1
    # Continue until pointers meet
    while left < right:
        # Swap elements at left and right pointers
        nums[left], nums[right] = nums[right], nums[left]
        # Move left pointer right
        left += 1
        # Move right pointer left
        right -= 1
    return nums
# Test the function
nums = [1, 2, 3]
print(reverse_array(nums))  # Output: [3, 2, 1]
```

**Problem 2**:
```python
# Function to find pair summing to target in sorted array
def find_pair(nums, target):
    # Initialize left pointer at start
    left = 0
    # Initialize right pointer at end
    right = len(nums) - 1
    # Continue until pointers meet
    while left < right:
        # Calculate current sum
        curr_sum = nums[left] + nums[right]
        # If sum equals target, return indices
        if curr_sum == target:
            return [left, right]
        # If sum is too small, move left pointer
        elif curr_sum < target:
            left += 1
        # If sum is too large, move right pointer
        else:
            right -= 1
    return []
# Test the function
nums = [1, 2, 3, 4]
target = 5
print(find_pair(nums, target))  # Output: [0, 2]
```

**Problem 3**:
```python
# Function to find max sum of 3 consecutive elements
def max_sum_k(nums, k=3):
    # Check if array is too small
    if len(nums) < k:
        return 0
    # Calculate sum of first k elements
    window_sum = sum(nums[:k])
    # Initialize max sum
    max_sum = window_sum
    # Slide window to end
    for i in range(k, len(nums)):
        # Add new element, remove oldest
        window_sum += nums[i] - nums[i - k]
        # Update max sum
        max_sum = max(max_sum, window_sum)
    return max_sum
# Test the function
nums = [1, 2, 3, 4]
print(max_sum_k(nums))  # Output: 9 (2 + 3 + 4)
```

**Problem 4**:
```python
# Function to remove duplicates from sorted array
def remove_duplicates(nums):
    # Check if array is empty
    if not nums:
        return 0
    # Initialize write pointer for unique elements
    write = 1
    # Iterate through array starting from second element
    for read in range(1, len(nums)):
        # If current element differs from previous
        if nums[read] != nums[write - 1]:
            # Write current element to write position
            nums[write] = nums[read]
            # Move write pointer
            write += 1
    return write
# Test the function
nums = [1, 1, 2]
print(remove_duplicates(nums))  # Output: 2
print(nums[:2])  # Output: [1, 2]
```

**Problem 5**:
```python
# Function to find longest substring without repeating characters
def longest_unique_substring(s):
    # Dictionary to store last position of each character
    seen = {}
    # Initialize window start and max length
    start = max_length = 0
    # Iterate through string
    for end in range(len(s)):
        # If character seen and within current window
        if s[end] in seen and seen[s[end]] >= start:
            # Move start to position after last occurrence
            start = seen[s[end]] + 1
        # Update max length of window
        max_length = max(max_length, end - start + 1)
        # Update character position
        seen[s[end]] = end
    return max_length
# Test the function
s = "abcabcbb"
print(longest_unique_substring(s))  # Output: 3 ("abc")
```

**Problem 6**:
```python
# Function to move zeros to end of array
def move_zeros(nums):
    # Initialize non-zero position
    non_zero_pos = 0
    # Move all non-zeros to front
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[non_zero_pos], nums[i] = nums[i], nums[non_zero_pos]
            non_zero_pos += 1
    return nums
# Test the function
nums = [0, 1, 0, 3]
print(move_zeros(nums))  # Output: [1, 3, 0, 0]
```

**Problem 7**:
```python
# Function to check if strings differ by one character
def one_edit_away(s1, s2):
    # Check if length difference is more than 1
    if abs(len(s1) - len(s2)) > 1:
        return False
    # Ensure s1 is shorter or equal
    if len(s1) > len(s2):
        s1, s2 = s2, s1
    # Initialize pointers
    i = j = edits = 0
    # Compare characters
    while i < len(s1) and j < len(s2):
        if s1[i] != s2[j]:
            # Increment edit count
            edits += 1
            # If lengths differ, move longer string pointer
            if len(s1) < len(s2):
                j += 1
            else:
                i += 1
                j += 1
            # If more than one edit, return False
            if edits > 1:
                return False
        else:
            i += 1
            j += 1
    # Check if extra character in s2
    if j < len(s2):
        edits += 1
    return edits <= 1
# Test the function
s1, s2 = "hello", "helo"
print(one_edit_away(s1, s2))  # Output: True
```

**Problem 8**:
```python
# Function to find min window size with sum >= target
def min_window_sum(nums, target):
    # Check if array is empty
    if not nums:
        return 0
    # Initialize window sum and min length
    curr_sum = 0
    min_length = float('inf')
    # Initialize window pointers
    start = 0
    # Iterate through array
    for end in range(len(nums)):
        # Add current element to sum
        curr_sum += nums[end]
        # Shrink window while sum >= target
        while curr_sum >= target:
            # Update min length
            min_length = min(min_length, end - start + 1)
            # Remove start element from sum
            curr_sum -= nums[start]
            # Move start pointer
            start += 1
    # Return 0 if no valid window found
    return min_length if min_length != float('inf') else 0
# Test the function
nums = [1, 2, 3, 4]
target = 6
print(min_window_sum(nums, target))  # Output: 2 (3 + 4)
```

**Problem 9**:
```python
# Function to partition array around value
def partition_array(nums, value):
    # Initialize left pointer for elements < value
    left = 0
    # Iterate through array
    for i in range(len(nums)):
        # If current element is less than value
        if nums[i] < value:
            # Swap with left pointer
            nums[left], nums[i] = nums[i], nums[left]
            # Move left pointer
            left += 1
    return nums
# Test the function
nums = [3, 1, 4, 2]
value = 3
print(partition_array(nums, value))  # Output: [1, 2, 4, 3]
```

**Problem 10**:
```python
# Function to count pairs with difference k
def count_pairs_diff(nums, k):
    # Initialize frequency dictionary
    freq = {}
    # Initialize count of pairs
    count = 0
    # Count frequencies
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    # For each number, check pairs
    for num in freq:
        # Check if num + k exists
        if num + k in freq:
            count += freq[num] * freq[num + k]
        # Check if num - k exists (for k != 0)
        if k != 0 and num - k in freq:
            count += freq[num] * freq[num - k]
    return count
# Test the function
nums = [1, 2, 3, 4]
k = 1
print(count_pairs_diff(nums, k))  # Output: 3 ([1,2], [2,3], [3,4])
```