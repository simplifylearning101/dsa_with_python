***

### File: `1_2.md`

```md
### Home work:

Here are 10-15 programs for you to practice what you learned today. Start simple and build up your skills! ðŸš€

---

**Problem:** Create a list of 5 fruits.

**Outcome:** A Python list containing five different fruit names as strings.

**Example:** `['apple', 'banana', 'cherry', 'date', 'elderberry']`

---

**Problem:** Access the second and last elements of a list.

**Outcome:** Print the values of the element at index 1 and the last element of the list.

**Example:**
* List: `[10, 20, 30, 40]`
* Output: `20` and `40`

---

**Problem:** Create a string with your full name. Access and print your first initial and your last initial using positive and negative indexing.

**Outcome:** Your first and last initials are printed to the console.

**Example:**
* String: `"John Doe"`
* Output: `J` and `e`

---

**Problem:** Slice a string to create a new string containing only the first three characters.

**Outcome:** A new string with the first three characters.

**Example:**
* String: `"Python"`
* Output: `"Pyt"`

---

**Problem:** Given a list, create a new list containing only the elements from the middle of the original list.

**Outcome:** A new list containing elements from index 2 to index 5 (inclusive).

**Example:**
* List: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
* Output: `[3, 4, 5, 6]`

---

**Problem:** Use a string slicing trick to reverse a string.

**Outcome:** A new string that is the reverse of the original.

**Example:**
* String: `"hello"`
* Output: `"olleh"`

---

**Problem:** Append a new number to an existing list of numbers.

**Outcome:** The original list is modified in-place with the new number at the end.

**Example:**
* List: `[1, 2, 3]`
* Append: `4`
* New List: `[1, 2, 3, 4]`

---

**Problem:** Given a list of names, remove the name "Bob".

**Outcome:** The list no longer contains "Bob". Use `list.remove()`.

**Example:**
* List: `['Alice', 'Bob', 'Charlie']`
* New List: `['Alice', 'Charlie']`

---

**Problem:** Create a function that takes a list of numbers and returns a new list where each number is squared. Use a loop to iterate through the list.

**Outcome:** A new list with all numbers squared.

**Example:**
* Input: `[1, 2, 3, 4]`
* Output: `[1, 4, 9, 16]`

---

**Problem:** Given a string, check if it's a palindrome (reads the same forwards and backwards).

**Outcome:** A boolean value (`True` or `False`). You can use string slicing to help.

**Example:**
* Input: `"racecar"` -> `True`
* Input: `"hello"` -> `False`

---

**Problem:** Given a list, insert a new element at the beginning of the list.

**Outcome:** The list is modified with the new element at index 0.

**Example:**
* List: `[10, 20]`
* Insert: `5`
* New List: `[5, 10, 20]`

---

**Problem:** Given a list of numbers, sort it in ascending order and then in descending order.

**Outcome:** The list is sorted first in ascending, then in descending order.

**Example:**
* Input: `[5, 1, 9, 3]`
* After ascending sort: `[1, 3, 5, 9]`
* After descending sort: `[9, 5, 3, 1]`

---

**Problem:** Take a list and a specific value. Check if the value exists in the list using the `in` operator.

**Outcome:** Print `True` if the value is in the list, `False` otherwise.

**Example:**
* List: `['a', 'b', 'c']`, Value: `'b'` -> `True`
* List: `['x', 'y', 'z']`, Value: `'d'` -> `False`

---

**Problem:** Given a sentence as a string, count how many times the letter 'a' appears.

**Outcome:** The total count of 'a's. Use a loop.

**Example:**
* String: `"apple and a banana"`
* Output: `5`
````

-----

### File: `1_3.md`

````md
### Solutions to problems:

```python
# --- Problem 1: Create a list of 5 fruits. ---
fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry']
print(f"My fruit list: {fruits}")

# --- Problem 2: Access the second and last elements. ---
my_list = [10, 20, 30, 40]
print(f"Second element: {my_list[1]}")
print(f"Last element: {my_list[-1]}")

# --- Problem 3: Access first and last initials. ---
full_name = "John Doe"
first_initial = full_name[0]
last_initial = full_name[-1]
print(f"First initial: {first_initial}")
print(f"Last initial: {last_initial}")

# --- Problem 4: Slice a string to get the first three characters. ---
original_string = "Python"
sliced_string = original_string[0:3]
print(f"Original string: {original_string}")
print(f"Sliced string: {sliced_string}")

# --- Problem 5: Slice a list for elements from the middle. ---
original_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
middle_slice = original_list[2:6] # Slice from index 2 up to, but not including, index 6
print(f"Original list: {original_list}")
print(f"Middle slice: {middle_slice}")

# --- Problem 6: Reverse a string using slicing. ---
word = "hello"
reversed_word = word[::-1]
print(f"Original word: {word}")
print(f"Reversed word: {reversed_word}")

# --- Problem 7: Append a new number to a list. ---
numbers = [1, 2, 3]
new_number = 4
numbers.append(new_number)
print(f"List after appending: {numbers}")

# --- Problem 8: Remove an element from a list. ---
names = ['Alice', 'Bob', 'Charlie']
names.remove('Bob') # Removes the first occurrence of 'Bob'
print(f"List after removing 'Bob': {names}")

# --- Problem 9: Function to square numbers in a list. ---
def square_numbers(input_list):
    """
    Takes a list of numbers and returns a new list with each number squared.
    """
    squared_list = []
    for num in input_list:
        squared_list.append(num * num)
    return squared_list

my_nums = [1, 2, 3, 4]
result = square_numbers(my_nums)
print(f"Original list: {my_nums}")
print(f"Squared list: {result}")

# --- Problem 10: Check if a string is a palindrome. ---
def is_palindrome(text):
    """
    Checks if a string is a palindrome (reads the same forwards and backwards).
    """
    # We can use the slicing trick to get the reversed string
    return text == text[::-1]

print(f"Is 'racecar' a palindrome? {is_palindrome('racecar')}")
print(f"Is 'hello' a palindrome? {is_palindrome('hello')}")

# --- Problem 11: Insert an element at the beginning of a list. ---
my_list = [10, 20]
my_list.insert(0, 5) # Insert 5 at index 0
print(f"List after inserting 5 at the beginning: {my_list}")

# --- Problem 12: Sort a list in ascending and descending order. ---
unsorted_list = [5, 1, 9, 3]
print(f"Original list: {unsorted_list}")
unsorted_list.sort() # Sorts in-place, ascending
print(f"Sorted ascending: {unsorted_list}")
unsorted_list.sort(reverse=True) # Sorts in-place, descending
print(f"Sorted descending: {unsorted_list}")

# --- Problem 13: Check for element existence using 'in'. ---
my_list_check = ['a', 'b', 'c']
value_to_find = 'b'
print(f"Is '{value_to_find}' in {my_list_check}? {value_to_find in my_list_check}")

value_to_find = 'd'
print(f"Is '{value_to_find}' in {my_list_check}? {value_to_find in my_list_check}")

# --- Problem 14: Count occurrences of a character in a string. ---
sentence = "apple and a banana"
count = 0
for char in sentence:
    if char == 'a':
        count += 1
print(f"The character 'a' appears {count} times in the string.")
````

````

***

### File: `1_4.md`

```md
### Quiz:

1.  What is the key difference between a Python list and a string?
2.  True or False: A Python list is an example of an immutable data structure.
3.  What is the index of the first element in a Python list?
4.  What will `my_list[-1]` return for the list `my_list = [1, 2, 3, 4]`?
5.  What does the `list.append()` method do?
6.  How can you remove an element from a list without knowing its index?
7.  What does the slicing syntax `my_string[2:5]` mean?
8.  Which of these is the most efficient way to add a single item to the end of a list: `append()` or `insert()`?
9.  What is the value of `len("Python")`?
10. How would you reverse a list `my_list = [1, 2, 3]` in-place?
11. True or False: Slicing a list always creates a new list.
12. What is the output of `print([1, 2, 3] * 2)`?
13. What is the value of `my_string[::2]` for `my_string = "abcdefg"`?
14. What happens if you try to modify a character in a string, like `my_string[0] = 'a'`?
15. What is the purpose of the `list.pop()` method?
16. If `my_list = [10, 20]`, what will `my_list.insert(0, 5)` result in?
17. What is the primary difference between `list.remove('b')` and `list.pop(1)`?
18. True or False: The `sort()` method on a list returns a new sorted list.
19. What is the output of `print("py" in "python")`?
20. Given `my_list = [1, 2, 3]`, what is the output of `my_list[1:2]`?
21. What's the output of `len([1, 'hello', True])`?
22. How do you access the last character of a string without knowing its length?
23. What is the output of `print(my_string[::-1])` for `my_string = "world"`?
24. What are the indices of the slice `my_list[1:4]`?
25. If `list_a = [1, 2]` and `list_b = [3, 4]`, what is the output of `print(list_a + list_b)`?
26. What happens if you try to access an index that is out of bounds for a list, e.g., `my_list[5]` for a 3-element list?
27. How does Python's `list.sort()` method work? (Hint: Does it return a new list or modify the original one?)
28. What data type is returned by a list slice?
29. What data type is returned by a string slice?
30. If you have a string `"12345"`, what is the output of `int(my_string[0]) + int(my_string[-1])`?

---

### Solutions for the quiz:

1.  Lists are mutable (can be changed); strings are immutable (cannot be changed).
2.  False. Lists are mutable.
3.  `0`.
4.  `4`.
5.  It adds an item to the end of the list.
6.  Use the `list.remove()` method.
7.  A slice of the string starting from index 2 and ending at (but not including) index 5.
8.  `append()`. It's an `O(1)` operation, while `insert()` at the end is also `O(1)`, `insert(0, ...)` is `O(n)`.
9.  `6`.
10. `my_list.reverse()` or `my_list[::-1]`.
11. True. Slicing always returns a new list.
12. `[1, 2, 3, 1, 2, 3]`.
13. `'aceg'`.
14. A `TypeError` will be raised because strings are immutable.
15. It removes and returns an element from the list, by default the last one.
16. `[5, 10, 20]`.
17. `remove()` takes a value to remove, while `pop()` takes an index.
18. False. `sort()` modifies the original list in-place and returns `None`.
19. `True`.
20. `[2]`. Slicing returns a list, even for a single element.
21. `3`.
22. Using negative indexing: `my_string[-1]`.
23. `'dlrow'`.
24. Indices 1, 2, and 3.
25. `[1, 2, 3, 4]`.
26. An `IndexError` will be raised.
27. It sorts the list in-place (modifies the original list) and returns `None`.
28. A `list`.
29. A `string`.
30. `6`. (1 + 5).
````

-----

### File: `1_5.md`

````md
### Deep dive on Lists and Strings

This deep dive is for those who want to understand the "why" behind the behaviors we've seen today. Knowing these underlying concepts will not only help you ace interviews but will also make you a more effective and efficient programmer.

#### Python Lists are Dynamic Arrays

When you create a list, Python allocates a block of memory to store pointers to the objects. This block has a certain capacity.
* **`append()` operation:** When you append an item, Python simply adds a new pointer to the end of the memory block. As long as there's space, this is a super-fast `O(1)` operation. However, when the list runs out of space, Python has to do something more complex: it allocates a **new, larger memory block** (usually 1.125x to 2x the original size), copies all the existing pointers to the new block, and then adds the new item. This resizing operation is `O(n)`, but because it happens infrequently, the average or **amortized time complexity** of `append()` is still considered `O(1)`. This is a classic interview question.

* **`insert(0, item)` and `pop(0)`:** These operations are very different. To insert an item at the beginning of a list, Python has to shift every single existing element one position to the right to make space. Similarly, to pop the first element, every other element has to be shifted to the left to fill the gap. This means both of these operations are **`O(n)`**, where `n` is the number of elements in the list. This is why you should avoid these operations on large lists if possible.

#### Why are Strings Immutable?

This is another favorite interview question. Here are the key reasons:
1.  **Performance and Memory Efficiency:** When you have multiple variables pointing to the same string literal (e.g., `s1 = "hello"`, `s2 = "hello"`), Python can use **string interning**. This means it stores only one copy of `"hello"` in memory, and both `s1` and `s2` point to the same memory location. If strings were mutable, changing `s1` would also change `s2`, which is undesirable and unpredictable. Immutability guarantees that this sharing is safe.
2.  **Hashing:** Since strings are immutable, their hash value can be cached when it's first computed. This makes strings suitable for use as keys in dictionaries, which require an immutable, hashable type.
3.  **Security:** Immutability can prevent unintended side effects. If a string object is passed to a function, you can be sure that the original string will not be modified by that function.

#### The Cost of String Concatenation

Let's look at a common mistake and how to fix it.

```python
# Inefficient String Concatenation
# This is O(n^2) because each addition creates a NEW string.
# A new memory block is allocated, and the old strings are copied over.
def bad_concat(words):
    result = ""
    for word in words:
        result += word + " "
    return result

# Efficient String Concatenation
# This is O(n) because Python calculates the final size first,
# then copies the parts into the new, single, memory block.
def good_concat(words):
    return " ".join(words)

# Example Usage
list_of_words = ["This", "is", "a", "test", "sentence."]
print(f"Bad concat: {bad_concat(list_of_words)}")
print(f"Good concat: {good_concat(list_of_words)}")
````

The interviewer's intention behind this question is to test your knowledge of how Python manages memory and whether you can write efficient, scalable code.

#### Interview Questions & Detailed Answers

**1. Question:** "What is the difference between a list and a tuple in Python?"
**Interviewer's Intention:** To check if you understand the core concept of mutability.
**Detailed Answer:**
A list is a **mutable** data structure, which means its elements can be modified, added, or removed after the list is created. Lists are defined using square brackets `[]`. Because they are dynamic, they are great for data that needs to change, like a user's shopping cart.
A tuple is an **immutable** data structure. Once it is created, its elements cannot be changed. Tuples are defined using parentheses `()`. They are generally more memory-efficient and slightly faster than lists. They are used for data that should not change, such as a set of coordinates or a date. Tuples are also hashable, making them suitable as dictionary keys.

**2. Question:** "Why should you use `join()` instead of the `+` operator for string concatenation?"
**Interviewer's Intention:** To assess your knowledge of performance and memory management in Python.
**Detailed Answer:**
Using the `+` operator for repeated string concatenation is inefficient because strings are immutable. Each time you use `+`, a **new string object** is created in memory, and the contents of the old strings are copied into it. For `n` concatenations, this results in a time complexity of `O(n^2)` because the total number of characters copied increases with each iteration.
In contrast, the `str.join()` method works by first calculating the total length of the final string. It then allocates memory for that string and copies the components into it in a single, efficient pass. This makes `join()` a much faster `O(n)` operation, especially for large numbers of concatenations.

````

***

### File: `1_6.md`

```md
### LeetCode / NeetCode problems

Let's apply what you've learned about Arrays and Strings to some common coding problems. Remember to always think about the most efficient solution.

---

**1. [Two Sum](https://leetcode.com/problems/two-sum/)**

**Problem Statement:**
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice. You can return the answer in any order.

**Example 1:**
* **Input:** `nums = [2, 7, 11, 15]`, `target = 9`
* **Output:** `[0, 1]`
* **Explanation:** Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.

**Example 2:**
* **Input:** `nums = [3, 2, 4]`, `target = 6`
* **Output:** `[1, 2]`

---

**2. [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)**

**Problem Statement:**
A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a palindrome, or `false` otherwise.

**Example 1:**
* **Input:** `s = "A man, a plan, a canal: Panama"`
* **Output:** `true`
* **Explanation:** `"amanaplanacanalpanama"` is a palindrome.

**Example 2:**
* **Input:** `s = "race a car"`
* **Output:** `false`
* **Explanation:** `"raceacar"` is not a palindrome.

---

**3. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)**

**Problem Statement:**
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**
* **Input:** `nums = [1, 2, 3, 1]`
* **Output:** `true`

**Example 2:**
* **Input:** `nums = [1, 2, 3, 4]`
* **Output:** `false`
````

-----

### File: `1_7.md`

````md
### Solutions for LeetCode / NeetCode problems

Let's break down the problems from 1_6.md and explore different ways to solve them, focusing on efficiency.

---

### 1. Two Sum

#### Problem Explanation:
The goal is to find two numbers in a given list that sum up to a target value and return their original indices.

#### Brute-Force Solution
The most straightforward approach is to use two nested loops. The outer loop iterates through each element, and the inner loop checks every other element to see if their sum equals the target.

```python
def two_sum_brute_force(nums, target):
    """
    Brute-force solution for Two Sum using nested loops.
    """
    # Outer loop to iterate through each element
    for i in range(len(nums)):
        # Inner loop to check all subsequent elements
        for j in range(i + 1, len(nums)):
            # Check if the sum of the pair equals the target
            if nums[i] + nums[j] == target:
                return [i, j]
    return [] # Should not be reached based on problem statement
````

  * **Pros:** Easy to understand and implement.
  * **Cons:** Inefficient for large inputs.
  * **Time Complexity:** `O(n^2)` because of the nested loops. The inner loop runs `n-1`, `n-2`, ..., `1` times.
  * **Space Complexity:** `O(1)` as we are not using any extra data structures.

#### Optimized Solution

A much better approach is to use a **hash map** (which is a Python dictionary). We can iterate through the list just once. For each element `x`, we calculate the "complement" needed to reach the target (`complement = target - x`). We then check if this `complement` is already in our hash map.

If it is, we've found our pair\! We return the current index and the index of the complement stored in the map. If the complement isn't in the map, we add the current element and its index to the map for future lookups.

```python
def two_sum_optimized(nums, target):
    """
    Optimized solution for Two Sum using a hash map (dictionary).
    """
    # Create a dictionary to store number -> index
    num_map = {}
    
    # Iterate through the list with both index and value
    for i, num in enumerate(nums):
        complement = target - num
        # Check if the complement is already in our map
        if complement in num_map:
            # If yes, we found our pair!
            return [num_map[complement], i]
        
        # If no, add the current number and its index to the map
        num_map[num] = i
    return [] # Should not be reached
```

  * **Pros:** Extremely efficient for large inputs.
  * **Cons:** Uses additional memory.
  * **Time Complexity:** `O(n)` because we only iterate through the list once. Dictionary lookups (`in num_map`) are on average `O(1)`.
  * **Space Complexity:** `O(n)` because in the worst case, we might store every element in the hash map.

-----

### 2\. Valid Palindrome

#### Problem Explanation:

The task is to determine if a string is a palindrome, ignoring non-alphanumeric characters and case.

#### Brute-Force Solution

The straightforward approach is to build a new, clean string that contains only the lowercase alphanumeric characters from the original string. Then, we can simply check if this new string is equal to its reverse.

```python
def is_palindrome_brute_force(s):
    """
    Brute-force solution for Valid Palindrome.
    """
    # 1. Create a new string with only alphanumeric characters, in lowercase
    new_string = ""
    for char in s:
        if 'a' <= char.lower() <= 'z' or '0' <= char <= '9':
            new_string += char.lower()
    
    # 2. Check if the new string is equal to its reverse
    return new_string == new_string[::-1]
```

  * **Pros:** The logic is simple and easy to follow.
  * **Cons:** Creates a new string, which can be memory-intensive for very long strings. Repeated string concatenation is `O(n^2)`.
  * **Time Complexity:** `O(n)` to build the new string (though with repeated `+` it can be `O(n^2)`), and `O(n)` to slice and reverse. Overall, it's roughly `O(n)`.
  * **Space Complexity:** `O(n)` because we create a new string of size `n`.

#### Optimized Solution (Two-Pointer Approach)

A more space-efficient solution uses the **two-pointer technique**. We initialize a left pointer at the beginning and a right pointer at the end of the string. We move the pointers inwards, skipping any non-alphanumeric characters. At each step, we compare the characters at the left and right pointers (after converting them to lowercase). If they don't match, it's not a palindrome. If the pointers cross, the string is a palindrome.

```python
def is_palindrome_optimized(s):
    """
    Optimized solution for Valid Palindrome using the two-pointer approach.
    """
    l, r = 0, len(s) - 1
    
    while l < r:
        # Move left pointer past non-alphanumeric characters
        while l < r and not s[l].isalnum():
            l += 1
        # Move right pointer past non-alphanumeric characters
        while l < r and not s[r].isalnum():
            r -= 1
        
        # Compare the lowercase characters
        if s[l].lower() != s[r].lower():
            return False
        
        # Move both pointers inwards
        l += 1
        r -= 1
    
    return True
```

  * **Pros:** Very memory efficient and avoids creating a new string.
  * **Cons:** Slightly more complex logic to handle the pointers.
  * **Time Complexity:** `O(n)` because we iterate through the string at most once.
  * **Space Complexity:** `O(1)` as we are not using any extra data structures.

-----

### 3\. Contains Duplicate

#### Problem Explanation:

Determine if any element in a list appears more than once.

#### Brute-Force Solution

A brute-force method is to use two nested loops. For each element, we check if it is equal to any of the subsequent elements.

```python
def contains_duplicate_brute_force(nums):
    """
    Brute-force solution for Contains Duplicate using nested loops.
    """
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return True
    return False
```

  * **Pros:** Simple and intuitive.
  * **Cons:** Very slow for large inputs.
  * **Time Complexity:** `O(n^2)`.
  * **Space Complexity:** `O(1)`.

#### Optimized Solution

A highly efficient solution uses a **hash set** (a Python `set`). A set stores unique elements and provides `O(1)` average time complexity for adding and checking for membership.

We can iterate through the list, adding each number to a set. Before we add a number, we check if it's already in the set. If it is, we've found a duplicate and can immediately return `True`. If we get through the entire list without finding a duplicate, we return `False`.

```python
def contains_duplicate_optimized(nums):
    """
    Optimized solution for Contains Duplicate using a hash set.
    """
    # Create an empty set to store numbers we have seen
    seen = set()
    
    # Iterate through each number in the list
    for num in nums:
        # Check if the number is already in the set
        if num in seen:
            return True
        # If not, add the number to the set
        seen.add(num)
        
    return False
```

  * **Pros:** Extremely fast and efficient.
  * **Cons:** Uses additional memory.
  * **Time Complexity:** `O(n)` because we iterate through the list once. Set operations (`add` and `in`) are on average `O(1)`.
  * **Space Complexity:** `O(n)` in the worst-case scenario where all elements are unique and we store all of them in the set.

<!-- end list -->

```
```