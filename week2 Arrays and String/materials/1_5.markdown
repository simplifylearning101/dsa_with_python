# 1_5.md

## Deep Dive: Arrays in Python
This section explores advanced array concepts using Python lists, focusing on multi-dimensional lists, pitfalls, and interview questions. Aimed at students seeking mastery.

### Complex Topics
1. **Multi-Dimensional Lists:** Used for matrices, grids, or tabular data. Common in graph or image processing problems.

**Example Program:**
```python
# Program to create and manipulate a 3x3 matrix
matrix = [
    [1, 2, 3],  # Row 0
    [4, 5, 6],  # Row 1
    [7, 8, 9]   # Row 2
]

# Access element at row 2, col 1
print("Element at (2,1):", matrix[2][1])  # Output: 8

# Print each row with its sum
for i, row in enumerate(matrix):
    print(f"Row {i} sum:", sum(row))  # Output: 6, 15, 24

# Create a 3x3 zero matrix using comprehension
zero_matrix = [[0 for _ in range(3)] for _ in range(3)]
print("Zero matrix:", zero_matrix)
```

**Complexity:** Accessing O(1), iterating O(m*n) for m rows, n columns.

2. **Advanced List Comprehension:** For 2D lists or complex patterns.

```python
# Create a 4x4 diagonal matrix
diagonal = [[1 if i == j else 0 for j in range(4)] for i in range(4)]
print("Diagonal:", diagonal)  # Output: [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]]
```

3. **Pitfalls:**
- **Modifying While Iterating:** Can skip elements or raise errors.
```python
lst = [1, 2, 3, 4]
for x in lst:  # Wrong: modifying during iteration
    if x % 2 == 0:
        lst.remove(x)  # Skips elements
print(lst)  # Unpredictable, e.g., [1, 3]

# Fix: Use copy
lst = [1, 2, 3, 4]
for x in lst[:]:  # Iterate over copy
    if x % 2 == 0:
        lst.remove(x)
print(lst)  # Output: [1, 3]
```
- **Shallow vs Deep Copy:** For nested lists, use `copy.deepcopy()` to avoid modifying originals.

4. **Memory Efficiency:** Lists over-allocate memory for fast appends (amortized O(1)).

### Interview Questions and Answers
1. **Question:** Why is list append O(1) amortized but insert O(n)?  
   **Answer:** Append adds to the end; Python over-allocates memory, so resizing is rare (O(1) amortized). Insert shifts elements, taking O(n).  
   **Intention:** Tests understanding of dynamic array mechanics.

2. **Question:** Reverse an array in-place.  
   **Answer:** Use two pointers swapping from ends to middle.  
   ```python
   def reverse_list(lst):
       left, right = 0, len(lst) - 1
       while left < right:
           lst[left], lst[right] = lst[right], lst[left]
           left += 1
           right -= 1
       return lst
   ```
   **Intention:** In-place operations, O(1) space.

3. **Question:** Find the maximum element in an array.  
   **Answer:** Iterate once, track max.  
   ```python
   def find_max(lst):
       if not lst:
           return None
       max_val = lst[0]
       for x in lst:
           if x > max_val:
               max_val = x
       return max_val
   ```
   **Intention:** Handle edge cases (empty list), O(n) time.

4. **Question:** Merge two sorted arrays into one sorted array.  
   **Answer:** Use two pointers to compare and build result.  
   ```python
   def merge_sorted(arr1, arr2):
       result = []
       i, j = 0, 0
       while i < len(arr1) and j < len(arr2):
           if arr1[i] <= arr2[j]:
               result.append(arr1[i])
               i += 1
           else:
               result.append(arr2[j])
               j += 1
       result.extend(arr1[i:])
       result.extend(arr2[j:])
       return result
   ```
   **Intention:** Tests pointer techniques, O(m+n) time.

5. **Question:** How to handle very large arrays in Python?  
   **Answer:** Use `numpy` for memory efficiency or generators to avoid loading all data. Discuss memory limits.  
   **Intention:** Practical considerations for scaling.

**Note:** Interviewers often ask about trade-offs (space vs time) and edge cases.