### Introduction to Arrays (Python Lists) and Strings

**Agenda :**

* Introduction to Arrays (Python Lists) and Strings.
* Understanding the key difference between these two data structures: mutability vs. immutability.
* Learning how to create, access, and manipulate lists and strings using indexing and slicing.
* Exploring common built-in methods for lists and strings.

**Outcome Expected:**

* Students will be able to confidently explain the fundamental differences between Python lists and strings.
* They will know how to perform basic operations such as creating, accessing elements, and slicing on both data types.
* Students will be proficient in using key built-in methods to modify lists and retrieve information from strings.

**Topics Covered**
1.  What are Arrays (Python Lists) and Strings?
2.  Mutability vs. Immutability
3.  Creating and initializing Lists and Strings
4.  Accessing elements using indexing (positive and negative)
5.  Slicing Lists and Strings
6.  Common List methods (append, pop, remove, sort, etc.)

---

### Detailed explanation of topics

#### 1. What are Arrays (Python Lists) and Strings?

In Python, we don't have a data structure called a "native array" like in C++ or Java. Instead, we use **Lists**, which are a very versatile and powerful data structure that behaves like a dynamic array. A **List** is an ordered collection of items, and it can hold different data types.

A **String** is a sequence of characters. It's used to store text. Think of it as a special kind of list, but with a critical difference we'll discuss next.

#### 2. Mutability vs. Immutability

This is arguably the most important concept to grasp about these two data structures.

* **Mutable:** A data structure that **can be changed** after it's created. **Python Lists are mutable**. You can add, remove, or change elements in a list.
* **Immutable:** A data structure that **cannot be changed** after it's created. **Python Strings are immutable**. If you want to "change" a string, you must create a new string with the desired changes.

Let's see this in action:

```python
# --- Mutability of Lists ---
my_list = [10, 20, 30, 40]
print(f"Original list: {my_list}")

# Change the element at index 1
my_list[1] = 99
print(f"List after changing an element: {my_list}") # Output: [10, 99, 30, 40]
```

```python
# --- Immutability of Strings ---
my_string = "Hello"
print(f"Original string: {my_string}")

# Let's try to change the character at index 1
# This will cause an error!
# my_string[1] = 'a' # This line would raise a TypeError: 'str' object does not support item assignment

# To "change" the string, we must create a new one
new_string = my_string[0] + 'a' + my_string[2:]
print(f"New string after "making a change": {new_string}") # Output: Heallo
```

#### 3\. Creating and Initializing Lists and Strings

Creating these data types is straightforward.

```python
# Creating an empty list
empty_list = []

# Creating a list with initial values (can be mixed types)
numbers = [1, 2, 3, 4, 5]
mixed_list = [10, "Hello", 3.14, True]

# Creating an empty string
empty_string = ""

# Creating a string with initial value
message = "Welcome to the class!"
```

#### 4\. Accessing elements using indexing

Both lists and strings are **indexed**, meaning each element or character has a unique position number. Indexing starts from `0`.

  * **Positive Indexing:** Starts from the beginning (left) at index `0`.
  * **Negative Indexing:** Starts from the end (right) at index `-1`.

<!-- end list -->

```python
my_list = ["apple", "banana", "cherry"]
my_string = "Python"

# --- Accessing with Positive Indexing ---
print(my_list[0])  # Output: apple
print(my_list[2])  # Output: cherry
print(my_string[0]) # Output: P
print(my_string[3]) # Output: h

# --- Accessing with Negative Indexing ---
print(my_list[-1]) # Output: cherry (the last element)
print(my_list[-2]) # Output: banana (the second to last element)
print(my_string[-1]) # Output: n
print(my_string[-6]) # Output: P
```

#### 5\. Slicing Lists and Strings

**Slicing** allows us to extract a part of a list or string. It creates a **new** list or string.

The general syntax is `[start:stop:step]`.

  * `start`: The index where the slice begins (inclusive).
  * `stop`: The index where the slice ends (exclusive).
  * `step`: The interval between elements. Defaults to 1.

<!-- end list -->

```python
my_list = [10, 20, 30, 40, 50, 60]
my_string = "programming"

# --- Basic Slicing ---
print(my_list[1:4])  # Output: [20, 30, 40] (from index 1 up to but not including 4)
print(my_string[2:7]) # Output: ogram (from index 2 up to but not including 7)

# --- Omitting start or stop ---
print(my_list[:3])   # Output: [10, 20, 30] (from the beginning to index 3)
print(my_string[4:])  # Output: amming (from index 4 to the end)
print(my_list[:])    # Output: [10, 20, 30, 40, 50, 60] (a full copy of the list)

# --- Slicing with a step ---
print(my_list[::2])  # Output: [10, 30, 50] (every second element)
print(my_string[::-1]) # Output: gnimmargorp (a common trick to reverse a string)
```

#### 6\. Common List methods

Python Lists have a ton of useful built-in methods. Let's look at some important ones for coding interviews.

| Method | Description | Example |
|---|---|---|
| `list.append(item)` | Adds `item` to the **end** of the list. | `fruits = ['apple']; fruits.append('orange')` -\> `['apple', 'orange']` |
| `list.insert(index, item)` | Inserts `item` at a specific `index`. | `fruits.insert(1, 'banana')` -\> `['apple', 'banana', 'orange']` |
| `list.pop([index])` | Removes and **returns** the item at `index`. If no index is given, it removes and returns the last item. | `fruits.pop(1)` -\> `['apple', 'orange']`. It also returns `'banana'`. |
| `list.remove(item)` | Removes the **first occurrence** of `item` from the list. | `fruits.remove('apple')` -\> `['orange']` |
| `list.sort()` | Sorts the list in place (modifies the original list). | `nums = [3, 1, 2]; nums.sort()` -\> `[1, 2, 3]` |
| `list.reverse()` | Reverses the list in place. | `nums = [1, 2, 3]; nums.reverse()` -\> `[3, 2, 1]` |
| `len(list)` | A built-in function to get the number of items in the list. | `len([10, 20])` -\> `2` |

-----

### Points to remember:

  * **Lists are mutable, strings are immutable.** This is the \#1 point to remember for any interview question about these two types. It affects how you can and cannot modify them.
  * **Indexing and slicing are your best friends.** Master them for both lists and strings. Slicing creates a **new** object.
  * **Time Complexity:** Be aware of the efficiency of operations.
      * `append()` on a list is typically `O(1)`.
      * `insert(0, item)` or `remove(0)` on a list is `O(n)` because all other elements have to be shifted.
      * `list.pop()` is `O(1)`, but `list.pop(0)` is `O(n)`.
  * **String Concatenation:** Using the `+` operator to concatenate strings repeatedly is **inefficient** because each operation creates a new string. For many concatenations, prefer `str.join()`, which is much faster. We'll cover this in more detail later.
  * **Check for element existence:** You can use the `in` keyword to check if an element is present in a list or string, which is very readable. For example, `if 'a' in 'banana'`.


