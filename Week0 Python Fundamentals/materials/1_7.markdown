# Solutions to Hour 1 LeetCode Problems

For each, explain, then brute-force and optimized solutions with time/space.

## 1. Fizz Buzz
Explanation: Loop 1 to n, check conditions, build list.

Brute-Force:
```python
# Simple loop
def fizzBuzz(n):
    result = []  # List
    for i in range(1, n+1):  # 1 to n
        if i % 15 == 0:  # Both
            result.append("FizzBuzz")
        elif i % 3 == 0:
            result.append("Fizz")
        elif i % 5 == 0:
            result.append("Buzz")
        else:
            result.append(str(i))
    return result
```
Time: O(n), Space: O(n). Pros: Simple. Cons: None really.

Optimized: Same, as it's optimal.

## 2. Palindrome Number
Explanation: Check if reads same forwards/backwards.

Brute-Force (String convert):
```python
def isPalindrome(x):
    if x < 0: return False
    s = str(x)  # Convert
    return s == s[::-1]  # Compare reverse
```
Time: O(d) where d digits, Space: O(d). Pros: Easy. Cons: Uses extra space.

Optimized (Math, no string):
```python
def isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0): return False
    rev = 0
    original = x
    while x > 0:  # Reverse half
        rev = rev * 10 + x % 10
        x //= 10
    return original == rev or original == rev // 10  # Handle odd length
```
Time: O(d), Space: O(1). Pros: Constant space. Cons: Handles edge cases.

## 3. Roman to Integer
Explanation: Map symbols, add/subtract based on order.

Brute-Force:
```python
def romanToInt(s):
    roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
    total = 0
    for i in range(len(s)):
        if i < len(s)-1 and roman[s[i]] < roman[s[i+1]]:  # Subtract
            total -= roman[s[i]]
        else:
            total += roman[s[i]]
    return total
```
Time: O(n), Space: O(1). Optimal already.

Optimized: Same.

## 4. Add Digits
Explanation: Sum digits until single.

Brute-Force (Loop):
```python
def addDigits(num):
    while num >= 10:  # Until single
        sum_digits = 0
        while num > 0:
            sum_digits += num % 10
            num //= 10
        num = sum_digits
    return num
```
Time: O(d log num), Space: O(1). Pros: Clear.

Optimized (Math: Digital Root):
```python
def addDigits(num):
    if num == 0: return 0
    return 1 + (num - 1) % 9  # Formula
```
Time: O(1), Space: O(1). Pros: Instant. Cons: Less intuitive.

## 5. Ugly Number
Explanation: Divide by 2,3,5 until 1.

Brute-Force:
```python
def isUgly(n):
    if n <= 0: return False
    for p in [2,3,5]:  # Divide
        while n % p == 0:
            n //= p
    return n == 1
```
Time: O(log n), Space: O(1). Optimal.

Optimized: Same.